# 动态规划算法学习心得（leetcode)
动态规划算法的实质是更好的优化**穷举**算法，即把算过的子树记录下来减少计算次数。  
储存计算过的子树的数列就是**dp数列**

使用动态规划有三个条件
  1.**最值问题**
    一般动态规划的使用场景是在求最值问题中，别的使用场景目前还没碰到，碰到后会更新后续（就是题做少了）
  2.**最优子结构**互相独立（在下面的零钱兑换中，每个硬币的数量都是无线的即一个硬币的数量不会影响另一个硬币的数量，如果一种硬币的使用数量会限制另一种硬币的可用数量，那么目前所用的方法将不会成立）
  3.**状态转移方程**，这是我在看各种讲解里看的最迷惑的一个点，什么是状态转移方程？状态是什么？怎么就转移了？其实说人话就是一个嵌套的条件函数，或者说就是套娃。e.g. F(x) = F(x-1) + F(x-2)
  
动态规划算法主要有**自上而下**与**自下而上**两种方法，二者在时间和空间复杂度上并无区别，两种根据应用情况各有优劣，目前只碰到过找零问题，在代码的理解上和简单性上**自下而上**更胜一筹。

## 解题心路历程
* 原题： leetcode 322. 零钱兑换：

  给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1
  
  例子
  coins = [1, 2, 5]
  amount = 11
  应当返回 3 （5+5+1）
  
  一开始碰到这个问题，在不知道动态规划的情况下，我第一个想到的是贪心算法，即取最大值硬币除以金额的余数，再利用余数对剩余硬币重复此过程，若余数为0，则返回到目前为止每次计算时的商的和。
  此方法能通过一些简单的用例，最终结果用的硬币有最大值硬币参与的时候是能够使用此算法的，但当碰到一些复杂的用例比如
  
  coins = [1, 5, 11]
  amount = 15
  此时应该返回的值为3（5+5+5）但根据贪心算法此时会返回5（11+1+1+1+1）
  
  显然这样的算法对于这道题的要求是不成立的
  
  在看了评论的解题思路以后发现这是一个动态规划问题，根据其中几个讲解跑了几个用例才逐渐理解这种方法，由此在下面会写出我学习的一些心得。
  
## 如何更好的理解动态规划自下而上的算法
我是一个喜欢看代码胜过看文字的人，所以接下来的心得也会根据这道题最后的代码来描述
```
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount >= 0 and coins:
            dp = [amount+1] * (amount+1)
            dp[0] = 0
            for coin in coins:
                for i in range(coin, amount+1):
                    dp[i] = min(dp[i], dp[i-coin]+1)
            if dp[amount] != (amount + 1):
                return dp[amount]
        return -1
```
### dp数列
首先是引入动态规划中一个非常重要的工具，也就是记录已经计算过的树的**dp数列**，代码中dp是一个amount+1长度的list,list的index代替了子树的根，比如说dp[2]意思就是当amount是2时，所需要的最少硬币数。一开始dp里的值可以是正无穷（float("inf")），也可以是amount+1（因为最多能够凑成amount的硬币数也就是amount个1块钱硬币，所以也能够看成是正无穷）。

### 套娃（状态转移方程）
代码中的`dp[i] = min(dp[i], dp[i-coin]+1)`就是这个方法的套娃方程， 对于当前amount，所需要的最少硬币数是{之前存储的硬币数或者是当前amount减去当前硬币值+1}中的较小的那一个。

举个例子，我们求dp[10]， 也就是要看我们所存的用之前硬币值算出的dp[i]和所存的dp[i-coin]+1哪个比较小，dp[i-coin]+1意思就是如果用了当前硬币，现在所使用的硬币数是多少。比如当前的硬币值是3，我们的套娃公式就变成，`dp[10] = min(dp[10], dp[10-3]+1)`,再比如我们之前所存的值是由币值为1的硬币算出来的（也就是说每个dp[i]=i），那么公式就是dp[10]=min(10,7+1),于是现在我们的**dp数列**里的dp[10]就变成了8。


弄明白了**dp数列**和**套娃公式**之后，再看这个方法在开始套娃之前都做了什么，首先设置 `dp[0] = 0` 给dp设置一个初始值，凑成0块钱需要0个硬币，在这个基础上我们再往上计算我们的树。
